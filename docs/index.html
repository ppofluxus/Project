<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OnSense - ì˜¤ëŠ˜ì˜ ê¸‰ì‹ ì•ˆë‚´</title>
  <link rel="preload" as="audio" href="./ONsensE-prototype.mp3" />
  <link rel="preload" as="audio" href="./ONsensE-prototype.m4a" />
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, 'Noto Sans KR', sans-serif;
      display: grid; place-items: center;
      min-height: 100dvh; margin: 0; background:#fff; color:#333;
      text-align:center;
    }
    h1 { font-size:1.5rem; margin:0 0 12px; }
    p  { margin:0 0 16px; color:#555; }
    .btn {
      display:inline-block; padding:12px 18px; border:0; border-radius:10px;
      background:#4caf50; color:#fff; font-size:1rem; cursor:pointer;
    }
    .btn[hidden] { display:none; }
  </style>
</head>
<body>
  <main>
    <h1>ì˜¤ëŠ˜ì˜ ê¸‰ì‹ ì•ˆë‚´ ğŸ§</h1>
    <p id="status">ì ì‹œ í›„ ìë™ìœ¼ë¡œ ì¬ìƒì„ ì‹œë„í•©ë‹ˆë‹¤â€¦</p>

    <!-- ìë™ì¬ìƒ ì‹¤íŒ¨ ì‹œ í‘œì‹œë  ë²„íŠ¼ -->
    <button id="playBtn" class="btn" hidden>â–¶ ìŒì„± ì¬ìƒ</button>

    <audio id="mealAudio" preload="auto" autoplay muted playsinline>
      <source src="./ONsensE-prototype.m4a" type="audio/mp4" />
      <source src="./ONsensE-prototype.mp3" type="audio/mpeg" />
      ë¸Œë¼ìš°ì €ê°€ ì˜¤ë””ì˜¤ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
    </audio>
  </main>

  <!-- ì²« ì§„ì… ì‹œ ìì—°ìŠ¤ëŸ¬ìš´ ì‚¬ìš©ì ì œìŠ¤ì²˜ ìœ ë„ë¥¼ ìœ„í•œ ì „ë©´ ê²Œì´íŠ¸ (ëª¨ë°”ì¼ ì¹œí™”) -->
  <div id="gate" role="button" tabindex="0" aria-label="í™”ë©´ì„ íƒ­í•˜ë©´ ìŒì„±ì´ ì¬ìƒë©ë‹ˆë‹¤"
       style="position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.5); color:#fff; font-size:1.05rem; z-index:9999;">
    í™”ë©´ì„ íƒ­í•˜ë©´ ìŒì„±ì´ ì¬ìƒë©ë‹ˆë‹¤
  </div>

  <script>
  const audio  = document.getElementById('mealAudio');
  const btn    = document.getElementById('playBtn');
  const status = document.getElementById('status');
  const gate   = document.getElementById('gate');

  function hideGate() { try { gate?.remove(); } catch(_) {} }

    // Web Audio context for broader compatibility (especially Safari)
  let audioCtx;
  let mediaSource;
  let gainNode;
  let userUnlocked = false; // ì‚¬ìš©ì ì œìŠ¤ì²˜ ë˜ëŠ” ëª…í™•í•œ ì¬ìƒ ì„±ê³µ ì´í›„ true
  let holdTimer = null;     // ì´ˆë°˜ ë³¼ë¥¨ ì•ˆì •í™” íƒ€ì´ë¨¸

    function ensureAudioGraph() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (!mediaSource) {
        mediaSource = audioCtx.createMediaElementSource(audio);
      }
      if (!gainNode) {
        gainNode = audioCtx.createGain();
        // ì´ˆê¸°ê°’ì„ 1ë¡œ ë‘ê³ , ìë™ì¬ìƒ ì •ì±…ì€ mutedë¡œ ì¤€ìˆ˜
        try { gainNode.gain.setValueAtTime(1.0, audioCtx.currentTime); } catch(_) {}
        mediaSource.connect(gainNode).connect(audioCtx.destination);
      }
    }

    async function rampUpVolume(durationMs = 400) {
      if (!audioCtx || !gainNode) return;
      const now = audioCtx.currentTime;
      const end = now + durationMs / 1000;
      // Smooth ramp to 100%
      try {
        gainNode.gain.cancelScheduledValues(now);
        gainNode.gain.setValueAtTime(gainNode.gain.value, now);
        gainNode.gain.linearRampToValueAtTime(1.0, end);
      } catch (_) {}
    }

    function lockFullVolume() {
      if (!audioCtx || !gainNode) return;
      const now = audioCtx.currentTime || 0;
      try {
        gainNode.gain.cancelScheduledValues(now);
        gainNode.gain.setValueAtTime(1.0, now);
      } catch(_) {}
      try { audio.volume = 1.0; } catch(_) {}
      try { audio.muted = false; } catch(_) {}
    }

    function startHoldVolume(seconds = 15) {
      if (holdTimer) return;
      const until = Date.now() + seconds * 1000;
      holdTimer = setInterval(() => {
        lockFullVolume();
        if (Date.now() > until || audio.ended) {
          clearInterval(holdTimer);
          holdTimer = null;
        }
      }, 1000);
    }

    async function tryAutoplay() {
      try {
        ensureAudioGraph();
        audio.muted = true; // policy ì¹œí™”ì  ì‹œì‘
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().catch(() => {});
        }
  await audio.play();
        status.textContent = 'ì¬ìƒ ì¤‘ì…ë‹ˆë‹¤. (ê³§ ì†Œë¦¬ê°€ ë‚˜ì˜µë‹ˆë‹¤)';
  hideGate();
  userUnlocked = true;
  startHoldVolume();
        setTimeout(() => { tryUnmute(); }, 300);
      } catch {
        btn.hidden = false;
        status.textContent = 'ë¸Œë¼ìš°ì € ì •ì±…ìœ¼ë¡œ ìë™ì¬ìƒì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.';
      }
    }

    function tryUnmute() {
      try {
        audio.muted = false;
        ensureAudioGraph();
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().catch(() => {});
        }
        rampUpVolume();
        if (userUnlocked) lockFullVolume();
        hideGate();
      } catch (_) {}
    }

    async function playWithUserGesture() {
      try {
        ensureAudioGraph();
        if (audioCtx && audioCtx.state === 'suspended') {
          await audioCtx.resume();
        }
        audio.muted = false;
        await audio.play();
        rampUpVolume();
        userUnlocked = true;
        startHoldVolume();
        hideGate();
        btn.hidden = true;
        status.textContent = 'ì¬ìƒ ì¤‘ì…ë‹ˆë‹¤ ğŸ¶';
      } catch (e) {
        status.textContent = 'ì¬ìƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì½˜ì†” ì˜¤ë¥˜ë¥¼ í™•ì¸í•˜ì„¸ìš”.';
      }
    }

    btn.addEventListener('click', playWithUserGesture);

    // ë²„íŠ¼ì„ ëˆ„ë¥´ì§€ ì•Šë”ë¼ë„, ì‚¬ìš©ìì˜ ì–´ë–¤ ì œìŠ¤ì²˜ë“  í—ˆìš©ë˜ë©´ ì¦‰ì‹œ ì¬ìƒ ì‹œë„
    // ëª¨ë°”ì¼/ë°ìŠ¤í¬í†±ì—ì„œ ì‚¬ìš©ì ì œìŠ¤ì²˜ë¡œ ì¸ì •ë˜ëŠ” ì´ë²¤íŠ¸ë“¤ì„ í­ë„“ê²Œ ìˆ˜ì§‘
    ;['click','pointerdown','pointerup','touchend','touchstart','keydown'].forEach(evt => {
      window.addEventListener(evt, () => {
        if (audio.paused || audio.muted) {
          playWithUserGesture();
        }
      }, { once: true, passive: true });
    });

    // ì „ë©´ ê²Œì´íŠ¸ì—ì„œì˜ í•œ ë²ˆì˜ íƒ­/í´ë¦­ìœ¼ë¡œë„ ì¦‰ì‹œ ì¬ìƒ
    if (gate) {
      const gatePlay = (e) => {
        // iOSì—ì„œ ì‚¬ìš©ì ì œìŠ¤ì²˜ ì»¨í…ìŠ¤íŠ¸ë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•´ ë™ê¸° ì‹¤í–‰
        e.preventDefault();
        playWithUserGesture();
        hideGate();
      };
      gate.addEventListener('pointerdown', gatePlay, { once:true, passive:false });
      gate.addEventListener('click', gatePlay, { once:true, passive:false });
      gate.addEventListener('touchend', gatePlay, { once:true, passive:false });
      gate.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') gatePlay(e);
      }, { once:true });
    }

    if (audio.readyState >= 2) {
      tryAutoplay();
    } else {
      audio.addEventListener('canplay', tryAutoplay, { once: true });
      setTimeout(tryAutoplay, 2000);
    }

    // íƒ­ì´ í™œì„±í™”ë˜ëŠ” ì‹œì ì—ë„ ì¬ì‹œë„ (ì¼ë¶€ í™˜ê²½ì—ì„œ íš¨ê³¼)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && (audio.paused || audio.muted)) {
        tryAutoplay();
      }
      if (document.visibilityState === 'visible' && userUnlocked) {
        startHoldVolume(8);
      }
    });

    // ì˜ˆê¸°ì¹˜ ì•Šì€ ë³¼ë¥¨ ë³€í™”ì— ëŒ€í•œ ë°©ì–´ë§‰
    audio.addEventListener('volumechange', () => {
      if (userUnlocked && (audio.muted || audio.volume < 0.99)) {
        lockFullVolume();
      }
    });
  </script>
</body>
</html>
