<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OnSense - 오늘의 급식 안내</title>
  <link rel="preload" as="audio" href="./ONsensE-prototype.mp3" />
  <link rel="preload" as="audio" href="./ONsensE-prototype.m4a" />
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, 'Noto Sans KR', sans-serif;
      display: grid; place-items: center;
      min-height: 100dvh; margin: 0; background:#fff; color:#333;
      text-align:center;
    }
    h1 { font-size:1.5rem; margin:0 0 12px; }
    p  { margin:0 0 16px; color:#555; }
    .btn {
      display:inline-block; padding:12px 18px; border:0; border-radius:10px;
      background:#4caf50; color:#fff; font-size:1rem; cursor:pointer;
    }
    .btn[hidden] { display:none; }
  </style>
</head>
<body>
  <main>
    <h1>오늘의 급식 안내 🎧</h1>
    <p id="status">잠시 후 자동으로 재생을 시도합니다…</p>

    <!-- 자동재생 실패 시 표시될 버튼 -->
    <button id="playBtn" class="btn" hidden>▶ 음성 재생</button>

    <audio id="mealAudio" preload="auto" autoplay muted playsinline>
      <source src="./ONsensE-prototype.m4a" type="audio/mp4" />
      <source src="./ONsensE-prototype.mp3" type="audio/mpeg" />
      브라우저가 오디오를 지원하지 않습니다.
    </audio>
  </main>

  <!-- 첫 진입 시 자연스러운 사용자 제스처 유도를 위한 전면 게이트 (모바일 친화) -->
  <div id="gate" role="button" tabindex="0" aria-label="화면을 탭하면 음성이 재생됩니다"
       style="position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.5); color:#fff; font-size:1.05rem; z-index:9999;">
    화면을 탭하면 음성이 재생됩니다
  </div>

  <script>
  const audio  = document.getElementById('mealAudio');
  const btn    = document.getElementById('playBtn');
  const status = document.getElementById('status');
  const gate   = document.getElementById('gate');

  function hideGate() { try { gate?.remove(); } catch(_) {} }

    // Web Audio context for broader compatibility (especially Safari)
    let audioCtx;
    let mediaSource;
    let gainNode;

    function ensureAudioGraph() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (!mediaSource) {
        mediaSource = audioCtx.createMediaElementSource(audio);
      }
      if (!gainNode) {
        gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(0.0, audioCtx.currentTime); // start silent
        mediaSource.connect(gainNode).connect(audioCtx.destination);
      }
    }

    async function rampUpVolume(durationMs = 600) {
      if (!audioCtx || !gainNode) return;
      const now = audioCtx.currentTime;
      const end = now + durationMs / 1000;
      // Smooth ramp to 100%
      try {
        gainNode.gain.cancelScheduledValues(now);
        gainNode.gain.setValueAtTime(gainNode.gain.value, now);
        gainNode.gain.linearRampToValueAtTime(1.0, end);
      } catch (_) {}
    }

    async function tryAutoplay() {
      try {
        // 대부분의 브라우저에서 허용되는 '무음/볼륨0 자동재생'
        ensureAudioGraph();
        audio.muted = true; // policy 친화적 시작
        if (audioCtx && audioCtx.state === 'suspended') {
          // 일부 브라우저는 사용자 제스처 없이 resume 불가 → 예외 무시
          audioCtx.resume().catch(() => {});
        }
        await audio.play();
        status.textContent = '재생 중입니다. (곧 소리가 나옵니다)';
        hideGate();
        // 재생이 시작되면 가능한 환경에서 점진적으로 음소거 해제 시도
        const unmuteAttempt = () => {
          tryUnmute();
          rampUpVolume();
        };
        audio.addEventListener('playing', () => {
          setTimeout(unmuteAttempt, 300);
          // 몇 초 동안 간헐적으로 재시도 (일부 데스크톱 브라우저에 유효)
          let tries = 0;
          const id = setInterval(() => {
            if (!audio.muted && (gainNode ? gainNode.gain.value >= 0.99 : true)) {
              clearInterval(id);
              return;
            }
            tries += 1;
            unmuteAttempt();
            if (tries > 6) clearInterval(id);
          }, 500);
        }, { once: true });
      } catch {
        // 자동재생 실패 → 버튼 노출
        btn.hidden = false;
        status.textContent = '브라우저 정책으로 자동재생이 차단되었습니다. 아래 버튼을 눌러주세요.';
      }
    }

    function tryUnmute() {
      try {
        audio.muted = false;
        // Web Audio 경로도 볼륨 상승 시도
        ensureAudioGraph();
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume().catch(() => {});
        }
        rampUpVolume();
        hideGate();
      } catch (_) {}
    }

    async function playWithUserGesture() {
      try {
        ensureAudioGraph();
        if (audioCtx && audioCtx.state === 'suspended') {
          await audioCtx.resume();
        }
        audio.muted = false;
        await audio.play();
        rampUpVolume();
        hideGate();
        btn.hidden = true;
        status.textContent = '재생 중입니다 🎶';
      } catch (e) {
        status.textContent = '재생에 실패했습니다. 콘솔 오류를 확인하세요.';
      }
    }

    btn.addEventListener('click', playWithUserGesture);

    // 버튼을 누르지 않더라도, 사용자의 어떤 제스처든 허용되면 즉시 재생 시도
    // 모바일/데스크톱에서 사용자 제스처로 인정되는 이벤트들을 폭넓게 수집
    ;['click','pointerdown','pointerup','touchend','touchstart','keydown'].forEach(evt => {
      window.addEventListener(evt, () => {
        if (audio.paused || audio.muted) {
          playWithUserGesture();
        }
      }, { once: true, passive: true });
    });

    // 전면 게이트에서의 한 번의 탭/클릭으로도 즉시 재생
    if (gate) {
      const gatePlay = (e) => {
        e.preventDefault();
        playWithUserGesture();
        hideGate();
      };
      gate.addEventListener('pointerdown', gatePlay, { once:true, passive:false });
      gate.addEventListener('click', gatePlay, { once:true, passive:false });
      gate.addEventListener('touchend', gatePlay, { once:true, passive:false });
      gate.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') gatePlay(e);
      }, { once:true });
    }

    // 소스가 준비되면 자동재생 시도
    if (audio.readyState >= 2) {
      tryAutoplay();
    } else {
      audio.addEventListener('canplay', tryAutoplay, { once: true });
      // 네트워크가 느릴 때도 일정 시간 후 시도
      setTimeout(tryAutoplay, 2000);
    }

    // 탭이 활성화되는 시점에도 재시도 (일부 환경에서 효과)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && (audio.paused || audio.muted)) {
        tryAutoplay();
      }
    });
  </script>
</body>
</html>
